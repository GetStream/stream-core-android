# .github/workflows/pr-checklist.yml
name: PR Quality check

on:
  pull_request:
    types: [opened, edited, synchronize, labeled, unlabeled, reopened]
  pull_request_target:
    types: [opened, edited, synchronize, labeled, unlabeled, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  pr-checklist:
    runs-on: ubuntu-latest

    steps:
      # --- Sanity: ensure we are running and print basic info (remove later) ---
      - name: Debug event
        run: |
          echo "event_name=${{ github.event_name }}"
          echo "PR #${{ github.event.pull_request.number }}"
          echo "Title: ${{ github.event.pull_request.title }}"
          echo "Labels: $(jq -r '.pull_request.labels[].name' <<< '${{ toJson(github.event) }}' | paste -sd, - || true)"

      - name: Validate PR
        id: validate
        env:
          TITLE_BYPASS_LABEL: pr:ignore-for-release
          MIN_TITLE_WORDS: "3"
          MAX_TITLE_WORDS: "12"
          EVENT_JSON: ${{ toJson(github.event) }}
        run: |
          set -euo pipefail

          # ---- inputs from event ----
          TITLE="$(jq -r '.pull_request.title' <<<"$EVENT_JSON")"
          BODY="$(jq -r '.pull_request.body // ""' <<<"$EVENT_JSON")"
          # labels array -> newline list
          mapfile -t LABELS < <(jq -r '.pull_request.labels[].name' <<<"$EVENT_JSON" || true)

          # ---- helpers ----
          has_label() {
            local want="$1"
            for l in "${LABELS[@]:-}"; do
              if [[ "$l" == "$want" ]]; then return 0; fi
            done
            return 1
          }
          has_any_pr_label() {
            for l in "${LABELS[@]:-}"; do
              [[ "$l" == pr:* ]] && return 0
            done
            return 1
          }

          failures=""

          # 1) Title length (unless bypass)
          if ! has_label "$TITLE_BYPASS_LABEL"; then
            title_words=$(echo "$TITLE" | tr -s '[:space:]' ' ' | sed -e 's/^ *//' -e 's/ *$//' | wc -w | xargs || true)
            : "${title_words:=0}"
            if (( title_words < MIN_TITLE_WORDS || title_words > MAX_TITLE_WORDS )); then
              failures+=$'\n'"- **Title** should be ${MIN_TITLE_WORDS}‚Äì${MAX_TITLE_WORDS} words for release notes. Current: ${title_words}. (Add \`${TITLE_BYPASS_LABEL}\` to bypass.)"
            fi
          fi

          # 2) At least one pr:* label
          if ! has_any_pr_label; then
            failures+=$'\n'"- Missing required label: at least one \`pr:\` label (e.g., \`pr:new-feature\`, \`pr:bug\`)."
          fi

          # 3) Required sections (accept any header level >=2; ignore comments/whitespace)
          section_nonempty () {
            local hdr="$1"
            # Match '##+ <hdr>' (two or more #'s), case-insensitive
            local section
            section="$(printf "%s" "$BODY" | awk -v IGNORECASE=1 -v h="^##+[[:space:]]*$hdr[[:space:]]*$" '
            BEGIN { insec=0 }
            $0 ~ h { insec=1; next }
            insec && $0 ~ /^##+[[:space:]]/ { insec=0 }
            insec { print }
            ')"
            # Strip HTML comments and whitespace-only lines
            section="$(printf "%s" "$section" \
              | sed -E 's/<!--(.|\n)*?-->//g' \
            | sed -E 's/^[[:space:]]+|[[:space:]]+$//g' \
            | sed '/^[[:space:]]*$/d')"
            [[ -n "$section" ]]
          }
  
  
          for hdr in Goal Implementation Testing; do
            if ! section_nonempty "$hdr"; then
              failures+=$'\n'"- Section **${hdr}** is missing or empty (use \`### ${hdr}\` with some content)."
            fi
          done

          if [[ -n "$failures" ]]; then
            echo "has_failures=true" >> "$GITHUB_OUTPUT"
            {
              echo 'failures<<EOF'
              printf "%b\n" "$failures"
              echo 'EOF'
            } >> "$GITHUB_OUTPUT"
            # Fail the job (branch protection can require this)
            exit 1
          else
            echo "has_failures=false" >> "$GITHUB_OUTPUT"
          fi

      # Only the pull_request_target run should write comments (fork-safe & has perms)
      - name: Find PR Checklist comment
        if: github.event_name == 'pull_request_target'
        id: find_comment
        uses: peter-evans/find-comment@v3
        with:
          issue-number: ${{ github.event.pull_request.number }}
          # Hidden anchor to ensure we always find the same comment
          body-includes: "<!-- pr-checklist-anchor -->"
          direction: last

      - name: Create or update failure comment (sticky ‚ùå)
        if: github.event_name == 'pull_request_target' && failure()
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.pull_request.number }}
          comment-id: ${{ steps.find_comment.outputs.comment-id }}
          edit-mode: replace
          body: |
            <!-- pr-checklist-anchor -->
            ### PR Checklist ‚ùå

            The following issues were detected:

            ${{ steps.validate.outputs.failures }}

            **We check**
            1. Title is concise (**3‚Äì12 words**) unless labeled `pr:ignore-for-release`.
            2. At least one `pr:` label exists.
            3. Sections `### Goal`, `### Implementation`, and `### Testing` contain content.

      - name: Create or update success comment (sticky ‚úÖ)
        if: github.event_name == 'pull_request_target' && success()
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.pull_request.number }}
          comment-id: ${{ steps.find_comment.outputs.comment-id }}
          edit-mode: replace
          body: |
            <!-- pr-checklist-anchor -->
            ### PR Checklist ‚úÖ

            All required conditions are satisfied:
            - Title length is OK (or ignored via `pr:ignore-for-release`).
            - At least one `pr:` label exists.
            - Sections `### Goal`, `### Implementation`, and `### Testing` are filled.

            üéâ Looks good!
